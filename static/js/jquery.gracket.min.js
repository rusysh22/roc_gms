// Enhanced Gracket implementation based on the documentation
(function($) {
    // Gracket class constructor
    function Gracket(container, options = {}) {
        this.container = typeof container === 'string' ? document.querySelector(container) : container;
        if (!this.container) {
            throw new Error('Container not found');
        }
        
        // Default settings
        this.settings = $.extend({
            src: [],
            gracketClass: 'g_gracket',
            gameClass: 'g_game',
            roundClass: 'g_round',
            roundLabelClass: 'g_round_label',
            teamClass: 'g_team',
            winnerClass: 'g_winner',
            currentClass: 'g_current',
            seedClass: 'g_seed',
            cornerRadius: 15,
            canvasId: 'g_canvas',
            canvasClass: 'g_canvas',
            canvasLineColor: '#667eea',
            canvasLineWidth: 2,
            canvasLineGap: 15,
            canvasLineCap: 'round',
            roundLabels: [],
            byeLabel: 'BYE',
            byeClass: 'g_bye',
            showByeGames: true,
            onScoreUpdate: null,
            onRoundComplete: null,
            onRoundGenerated: null
        }, options);

        this.bracketData = this.settings.src;
        this.roundLabels = this.settings.roundLabels;
        
        this.init();
    }

    Gracket.prototype = {
        init: function() {
            this.render();
            this.bindEvents();
        },

        render: function() {
            var $container = $(this.container);
            $container.addClass(this.settings.gracketClass).empty();

            // Create canvas for bracket lines
            var canvas = $('<canvas>', {
                'id': this.settings.canvasId,
                'class': this.settings.canvasClass,
                'css': {
                    'position': 'absolute',
                    'top': '0',
                    'left': '0',
                    'width': '100%',
                    'height': '100%',
                    'z-index': '1',
                    'pointer-events': 'none'
                }
            });
            $container.append(canvas);

            // Create rounds container with proper styling
            var roundsContainer = $('<div>', {
                'class': 'g_gracket_content',
                'css': {
                    'position': 'relative',
                    'z-index': '2'
                }
            });
            $container.append(roundsContainer);

            // Process each round
            $.each(this.bracketData, function(roundIndex, round) {
                var $round = $('<div>', {
                    'class': this.settings.roundClass,
                    'css': {
                        'margin-right': '80px',
                        'min-width': '200px',
                        'display': 'inline-block',
                        'vertical-align': 'top'
                    }
                });

                // Add round label above the round
                if (this.roundLabels[roundIndex]) {
                    var $roundLabel = $('<div>', {
                        'class': this.settings.roundLabelClass,
                        'text': this.roundLabels[roundIndex],
                        'css': {
                            'margin-bottom': '25px',
                            'text-align': 'center',
                            'width': '100%',
                            'font-weight': 'bold',
                            'color': '#424242',
                            'font-size': '16px',
                            'text-transform': 'uppercase',
                            'letter-spacing': '0.5px'
                        }
                    });
                    $round.append($roundLabel);
                }

                // Process each game in the round
                var $gamesContainer = $('<div>');
                $.each(round, function(gameIndex, game) {
                    var $game = $('<div>', {
                        'class': this.settings.gameClass,
                        'data-round': roundIndex,
                        'data-game': gameIndex,
                        'css': {
                            'margin-bottom': '20px',
                            'position': 'relative',
                            'background': '#fff',
                            'border-radius': '6px',
                            'box-shadow': '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
                            'transition': 'all 0.3s cubic-bezier(.25,.8,.25,1)',
                            'border': '1px solid #e0e0e0'
                        }
                    });

                    // Process teams in the game
                    var $teamsContainer = $('<div>');
                    $.each(game, function(teamIndex, team) {
                        var $teamContainer = $('<div>', {
                            'class': this.settings.teamClass,
                            'data-team-id': team.id || 'team-' + roundIndex + '-' + gameIndex + '-' + teamIndex,
                            'data-seed': team.seed,
                            'css': {
                                'padding': '10px 12px',
                                'display': 'flex',
                                'justify-content': 'space-between',
                                'align-items': 'center',
                                'border-bottom': teamIndex < game.length - 1 ? '1px solid #eee' : 'none'
                            }
                        });

                        // Create team content
                        var teamContent = '';
                        if (team.seed) {
                            teamContent += '<span class="' + this.settings.seedClass + '">#' + team.seed + '</span> ';
                        }
                        teamContent += team.name;

                        // Add score if available
                        if (team.score !== undefined && team.score !== null) {
                            teamContent += ' <span class="g_team_score">' + team.score + '</span>';
                        }

                        $teamContainer.html('<h4 style="margin: 0; font-size: 14px; font-weight: 500;">' + teamContent + '</h4>');
                        $teamsContainer.append($teamContainer);
                    }.bind(this));

                    // Handle bye games (single team)
                    if (game.length === 1) {
                        var $byeContainer = $('<div>', {
                            'class': this.settings.byeClass + ' ' + this.settings.teamClass,
                            'css': {
                                'padding': '10px 12px',
                                'display': 'flex',
                                'justify-content': 'space-between',
                                'align-items': 'center',
                                'background': 'linear-gradient(90deg, #f8f9fa 0%, #e9ecef 100%)',
                                'border-left': '4px dashed #6c757d',
                                'opacity': '0.6',
                                'font-style': 'italic'
                            }
                        });
                        $byeContainer.html('<h4 style="margin: 0; font-size: 14px; font-weight: 500;">' + this.settings.byeLabel + '</h4>');
                        $teamsContainer.append($byeContainer);
                    }

                    $game.append($teamsContainer);
                    $gamesContainer.append($game);
                }.bind(this));

                $round.append($gamesContainer);
                roundsContainer.append($round);
            }.bind(this));

            // Draw connections after DOM is rendered
            setTimeout(function() {
                this.drawBracketConnections();
            }.bind(this), 100);
        },

        drawBracketConnections: function() {
            var canvasElement = document.getElementById(this.settings.canvasId);
            if (!canvasElement) return;

            var container = this.container;
            canvasElement.width = container.scrollWidth || container.offsetWidth;
            canvasElement.height = container.scrollHeight || container.offsetHeight;

            var ctx = canvasElement.getContext('2d');
            if (!ctx) return;

            ctx.strokeStyle = this.settings.canvasLineColor;
            ctx.lineWidth = this.settings.canvasLineWidth;
            ctx.lineCap = this.settings.canvasLineCap;
            ctx.lineJoin = 'round';

            var roundElements = document.querySelectorAll('.' + this.settings.roundClass);

            for (var roundIdx = 0; roundIdx < this.bracketData.length - 1; roundIdx++) {
                var gamesInRound = this.bracketData[roundIdx];
                var nextRoundGames = this.bracketData[roundIdx + 1];

                if (roundElements[roundIdx] && roundElements[roundIdx + 1]) {
                    var currentRoundRect = roundElements[roundIdx].getBoundingClientRect();
                    var nextRoundRect = roundElements[roundIdx + 1].getBoundingClientRect();

                    var containerRect = canvasElement.getBoundingClientRect();

                    var startX = currentRoundRect.right - containerRect.left;
                    var endX = nextRoundRect.left - containerRect.left;

                    for (var gameIdx = 0; gameIdx < gamesInRound.length; gameIdx += 2) {
                        var nextGameIdx = Math.floor(gameIdx / 2);

                        var currentGames = roundElements[roundIdx].querySelectorAll('.' + this.settings.gameClass);
                        var nextGames = roundElements[roundIdx + 1].querySelectorAll('.' + this.settings.gameClass);

                        if (currentGames[gameIdx] && currentGames[gameIdx + 1] && nextGames[nextGameIdx]) {
                            var game1Rect = currentGames[gameIdx].getBoundingClientRect();
                            var game2Rect = currentGames[gameIdx + 1].getBoundingClientRect();
                            var nextGameRect = nextGames[nextGameIdx].getBoundingClientRect();

                            var y1 = game1Rect.top - containerRect.top + game1Rect.height / 2;
                            var y2 = game2Rect.top - containerRect.top + game2Rect.height / 2;
                            var yNext = nextGameRect.top - containerRect.top + nextGameRect.height / 2;

                            ctx.beginPath();

                            ctx.moveTo(startX, y1);
                            ctx.lineTo(startX + this.settings.canvasLineGap, y1);

                            ctx.lineTo(startX + this.settings.canvasLineGap, (y1 + y2) / 2);

                            ctx.lineTo(endX - this.settings.canvasLineGap, (y1 + y2) / 2);

                            ctx.lineTo(endX - this.settings.canvasLineGap, yNext);

                            ctx.lineTo(endX, yNext);

                            ctx.stroke();
                        }
                    }
                }
            }
        },

        bindEvents: function() {
            this.addHoverHighlighting();
        },

        addHoverHighlighting: function() {
            var self = this;
            $('.' + this.settings.teamClass).on('mouseenter', function() {
                var teamId = $(this).data('team-id');
                if (!teamId) return;

                $('.' + self.settings.teamClass).each(function() {
                    var thisTeamId = $(this).data('team-id');
                    if (thisTeamId === teamId) {
                        $(this).closest('.' + self.settings.gameClass).addClass(self.settings.currentClass);
                    }
                });
            }).on('mouseleave', function() {
                $('.' + self.settings.gameClass).removeClass(self.settings.currentClass);
            });
        },

        // Update score method from documentation
        updateScore: function(roundIndex, gameIndex, teamIndex, score) {
            if (this.bracketData[roundIndex] && 
                this.bracketData[roundIndex][gameIndex] && 
                this.bracketData[roundIndex][gameIndex][teamIndex]) {
                
                this.bracketData[roundIndex][gameIndex][teamIndex].score = score;
                
                // Update the displayed score
                var $teamElement = $('[data-round="' + roundIndex + '"][data-game="' + gameIndex + '"] .' + this.settings.teamClass).eq(teamIndex);
                $teamElement.find('.g_team_score').text(score);
                
                // Call the callback if provided
                if (typeof this.settings.onScoreUpdate === 'function') {
                    this.settings.onScoreUpdate(roundIndex, gameIndex, teamIndex, score);
                }
                
                // Redraw connections to maintain visual integrity
                setTimeout(function() {
                    self.drawBracketConnections();
                }, 50);
            }
        },

        // Get match winner method from documentation
        getMatchWinner: function(roundIndex, gameIndex) {
            if (this.bracketData[roundIndex] && this.bracketData[roundIndex][gameIndex]) {
                var game = this.bracketData[roundIndex][gameIndex];
                
                if (game.length === 1) {
                    // This is a bye - the single team advances
                    return game[0];
                } else if (game.length === 2 && game[0].score !== undefined && game[1].score !== undefined) {
                    // Regular match with scores - return the team with higher score
                    return game[0].score > game[1].score ? game[0] : game[1];
                }
            }
            return null;
        },

        // Check if round is complete method from documentation
        isRoundComplete: function(roundIndex) {
            if (!this.bracketData[roundIndex]) return false;
            
            for (var i = 0; i < this.bracketData[roundIndex].length; i++) {
                var game = this.bracketData[roundIndex][i];
                
                // If it's a bye game (1 team), it's complete
                if (game.length === 1) continue;
                
                // If it's a regular game (2 teams) and one doesn't have a score, round isn't complete
                if (game.length === 2) {
                    if (game[0].score === undefined || game[1].score === undefined) {
                        return false;
                    }
                }
            }
            return true;
        },

        // Get advancing teams method from documentation
        getAdvancingTeams: function(roundIndex) {
            var advancingTeams = [];
            if (roundIndex === undefined) {
                // Find the latest completed round
                for (var i = this.bracketData.length - 1; i >= 0; i--) {
                    if (this.isRoundComplete(i)) {
                        roundIndex = i;
                        break;
                    }
                }
            }

            if (roundIndex !== undefined && this.bracketData[roundIndex]) {
                for (var i = 0; i < this.bracketData[roundIndex].length; i++) {
                    var winner = this.getMatchWinner(roundIndex, i);
                    if (winner) {
                        advancingTeams.push(winner);
                    }
                }
            }
            return advancingTeams;
        },

        // Get the current data
        getData: function() {
            // Return a deep copy to prevent external modifications
            return JSON.parse(JSON.stringify(this.bracketData));
        },

        // Basic update method
        update: function(newData) {
            this.bracketData = newData;
            this.render();
        },

        // Destroy method to clean up
        destroy: function() {
            $(this.container).off();
            $(this.container).empty();
        }
    };

    // jQuery plugin wrapper
    $.fn.gracket = function(options) {
        return this.each(function() {
            var instance = new Gracket(this, options);
            $(this).data('gracket', instance);
        });
    };

    // Function to generate tournament with byes (from documentation)
    function generateTournamentWithByes(teams, strategy = 'top-seeds') {
        // Calculate number of byes needed
        const teamCount = teams.length;
        const nextPowerOfTwo = Math.pow(2, Math.ceil(Math.log2(teamCount)));
        const byesNeeded = nextPowerOfTwo - teamCount;
        
        // Sort teams by seed for 'top-seeds' strategy
        const sortedTeams = strategy === 'top-seeds' 
            ? [...teams].sort((a, b) => a.seed - b.seed) 
            : strategy === 'random' 
                ? [...teams].sort(() => Math.random() - 0.5) 
                : [...teams];
        
        // Create tournament structure
        const rounds = [];
        let currentRound = [];
        
        // Create games for teams that need to play (non-bye teams)
        const teamsToPlay = sortedTeams.slice(byesNeeded);
        const teamsWithByes = sortedTeams.slice(0, byesNeeded);
        
        // Create games for teams that need to play
        for (let i = 0; i < teamsToPlay.length; i += 2) {
            if (i + 1 < teamsToPlay.length) {
                currentRound.push([
                    { ...teamsToPlay[i], score: null },
                    { ...teamsToPlay[i + 1], score: null }
                ]);
            } else {
                // Odd team out - add as bye
                currentRound.push([{ ...teamsToPlay[i], score: null }]);
            }
        }
        
        // Add teams with byes
        teamsWithByes.forEach(team => {
            currentRound.push([{ ...team, score: null }]);
        });
        
        rounds.push(currentRound);
        
        // Add subsequent rounds (empty for now, to be filled as tournament progresses)
        let teamsForNextRound = nextPowerOfTwo / 2;
        while (teamsForNextRound > 1) {
            const nextRound = Array.from({ length: teamsForNextRound / 2 }, () => []);
            rounds.push(nextRound);
            teamsForNextRound /= 2;
        }
        
        // Add champion round
        rounds.push([[]]);
        
        return rounds;
    }

    // Make functions available globally
    window.Gracket = Gracket;
    window.generateTournamentWithByes = generateTournamentWithByes;

})(jQuery);